#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
from bs4 import BeautifulSoup
import time

__author__     = "Leon Schnieber"
__copyright__  = "Copyright 2018"
__credits__    = "fischertechnik GmbH"
__maintainer__ = "Leon Schnieber"
__email__      = "olaginos-buero@outlook.de"
__status__     = "Developement"


class RoboProObject(object):
    """
    This object can be either generated by an XML-String or via the attributes
    itself. Therefor objectXmlSoup has to be None so the attributes can be set
    manually. This feature is mainly used for Pseudo-Objects used on converging
    wires.
    """
    normal = 0
    reverse = 1

    def __init__(self, subroutineToolbox, objectXmlSoup=None):
        self._objectRaw = objectXmlSoup
        self._subrtTools = subroutineToolbox
        self._data = None  # Empty variable e.g. to use for constants etc.
        self._type = None  # Category of the block, e.g. ftProProcessStart
        self._id = ""  # Internal ID given in the XML-Structure
        self._pins = []  # list of data- and flow-connection-pins
        if self._objectRaw is not None:
            self.parse()

    def __repr__(self):
        return "RoObj_" + self._id + "_" + self._type

    def parse(self):
        '''
        Extract all necessary informations about this Diagram-Block out of the
        given XML-Structure and store it in different Variables.
        '''
        self._type = self._objectRaw.attrs["classname"]
        try:
            self._id = self._objectRaw.attrs["id"]
        except KeyError:
            self._id = ""
        pinList = self._objectRaw.find_all("o", attrs=
            {"classname": "ftProObjectPin"})
        for pin in pinList:
            pinData = {
                "id": pin.attrs["id"],
                "pinid": pin.attrs["pinid"],
                "name": pin.attrs["name"],
                "pinclass": pin.attrs["pinclass"]
            }
            self._pins.append(pinData)

    def getPinIdByClass(self, pinclass):
        '''
        Fetch and return all connection pins of a given type
        '''
        return self.getPinIdByAttr("pinclass", pinclass)

    def getPinIdByAttr(self, attr, value):
        '''
        Fetch and return all connection pins of a given type and value
        '''
        list = []
        for pin in self._pins:
            if value in pin[attr]:
                list.append(pin["id"])
        return list

    def run(self, inputID=None, arguments={}, mode=0):
        '''
        This function is called by the Subroutine-Object. Depending on its object
        type it takes additional input arguments (e.g. Input-Sensors or variables)
        and returns the next coutputID (e.g. important for an if-else-Block).
        Additionally it may return additional Arguments, e.g. for Motor-Outputs.
        Depending on the mode-argument the single elements change their propagation-
        behaviour. In normal Mode, they act forward, so they only find their "next"
        object in the chain. In reverse-Mode they backpropagate to get the values
        they work with. Not all blocks have to handle with that but there are some
        where this is quite helpful.
        '''
        outputID = None
        print(self)
        if self._type == "ftProProcessStart": # program start block
            outputID = self.getPinIdByClass("flowobjectoutput")[0]
        elif self._type == "ftProFlowIf":  # if block
            styleNo = int(self._objectRaw.attrs["style"])
            # style-types:
            # 1  = 8.6-Verzweigung mit Dateneingang
            # 2  = 8.1-Verzweigung Digital
            if styleNo == 1: # Verzweigung mit Dateneingang
                # Get Pin-IDs for the Yes-Outputs and No-Outputs
                outYes = self.getPinIdByAttr("name", "J")[0]
                outNo = self.getPinIdByAttr("name", "N")[0]
                # start backpropagating process to get a value for the comparsion
                pinIDin = self.getPinIdByClass("dataobjectinput")[0]
                # get the backpropagated value and return IDs depending on the value
                val = self.calculateDataValue(pinIDin)["value"]
            elif styleNo == 2:  # Verzweigung Digital
                outYes = self.getPinIdByAttr("name", "1")[0]
                outNo = self.getPinIdByAttr("name", "0")[0]
                IFNo, IFPortNo, IFPortMode = self.readInputMeta()
                val = self._subrtTools._io.getSensorValue(IFNo, IFPortNo, IFPortMode)
            if val == 1 or val == True or val > 0:
                outputID = outYes
            else:
                outputID = outNo
        elif self._type == "ftProDataIn": # sensor/data-in block
            # fetch type dependent settings
            IFNo, IFPortNo, IFPortMode = self.readInputMeta()
            arguments["value"] = True # TODO: connect to IO-Wrapper
        elif self._type == "dataHelper": # merging Cable nodes
            if mode == self.normal:
                # for pin in self._pins:
                #     print(pin)
                try:
                    outputID = self.getPinIdByAttr("name", "flowobjectoutput")[0]
                except IndexError:
                    outputID = self.getPinIdByAttr("name", "dataobjectoutput")[0]
                # outputID = self._subrtTools._followWire(outputID)
                # print("HEY", self._subrtTools._findObject(outputID)[1])
            elif mode == self.reverse:
                pass
        elif self._type == "ftProDataMssg":
            if mode == self.normal:
                pinIDIn = self.getPinIdByClass("dataobjectinput")
                if len(pinIDIn) >= 1:
                    # backpropagate data from the connecting wires
                    value = int(self.calculateDataValue(pinIDIn[0])["value"])
                else:
                    # get the value from the metadata
                    value = int(self._objectRaw.attrs["value"])
                comType = self._objectRaw.attrs["command"]
                # List of availiable types
                # "="    = Set      (= n)
                # "+"    = Incr     (= n+1)
                # "-"    = Decr     (= n-1)
                # "cw"   = CW Mot   (v=n)
                # "ccw"  = CCW Mot  (v=n)
                # "Stop" = Stop Mot (v=0)
                # "On"   = On IO    (v=n)
                # "Off"  = Off IO   (v=0)
                # "Ap…d" = Append n to list
                # "Re…e" = Remove nth list-element
                # "Swap" = Swap nth element with first element in list

                # "branch out" of subroutine-run-thread and try to reach all connected wires with the data
                # "frontpropagate" all paths and call their "run"-Functions
                arguments = {
                "commandType": comType,
                "value": value
                }
                tOutputID = self.getPinIdByClass("dataobjectoutput")[0]
                self.calculateFollowers(tOutputID, arguments)
                outputID = self.getPinIdByClass("flowobjectoutput")[0]
            elif mode == self.reverse:
                pass # do nothing, the object isn't called actively
        elif self._type == "ftProDataOutDual":
            # if this object is used as an Level 1 Object, it has to fetch its arguments by itself
            if "classic" in self._objectRaw.attrs:
                arguments["commandType"] = self._objectRaw.attrs["command"]
                if self._objectRaw.attrs["value"] == "-32768":
                    arguments["value"] = 0
                else:
                    arguments["value"] = int(self._objectRaw.attrs["value"]) * 64 # directly multiply because of classic-elements not supporting 512-step-mode
                # in classic mode elements have to find their output for the next element
                outputID = self.getPinIdByClass("flowobjectoutput")[0]
            # get Details
            IFaceNumber = self._objectRaw.attrs["module"]
            IFacePortNo = int(self._objectRaw.attrs["output"])
            try:
                IFacePortRes = int(self._objectRaw.attrs["resolution"])
                if IFacePortRes == 0:  # if resolution is 0-8 convert it to 512-System
                    arguments["value"] = int(arguments["value"]) * 64
            except KeyError:
                pass
            # do something with the IO
            self._subrtTools._io.setOutputValue(IFaceNumber, IFacePortNo, arguments)

        elif self._type == "ftProDataConst":
            arguments["value"] = int(self._objectRaw.attrs["value"])
        elif self._type == "ftProFlowDelay":
            # attrs["userscale"] = 0: 1s
            # attrs["userscale"] = 1: 1min
            # attrs["userscale"] = 2: 1h
            # value = int(self._objectRaw.attrs["scale"]) * int(self._objectRaw.attrs["uservalue"])
            value = int(self._objectRaw.attrs["value"]) / 1000
            time.sleep(value)
            outputID = self.getPinIdByClass("flowobjectoutput")[0]
        elif self._type == "ftProProcessStop":
            outputID = None
            arguments = None
        else:
            print("ERROR:", self._type, "isn't yet implemented.")
        return outputID, arguments

    def calculateDataValue(self, pinIDin):
        '''
        This function is especially important for objects who use data-flow-wires
        to get their information. It tries to follow the orange connections in
        reverse direction, back to their origins. (in reverse-direction-mode)
        '''
        dataInBack = self._subrtTools._followWireReverse(pinIDin)
        pins, objectBack = self._subrtTools._findObject(dataInBack)
        outputID, arguments = objectBack.run(mode=self.reverse)
        return arguments

    def calculateFollowers(self, pinIDout, arguments):
        '''
        This function follows the orange wires to all open ends and tries to "run"
        them in normal-direction-mode so motors can be set etc.
        '''
        dataInNext = self._subrtTools._followWireList(pinIDout)
        for wire in dataInNext:
            objPinList, obj = self._subrtTools._findObject(wire)
            outputID, arguments = obj.run(arguments=arguments)
            while outputID is not None:
                folWir = self._subrtTools._followWire(outputID)
                pinList, object = self._subrtTools._findObject(folWir)
                if object is not None:
                    object.run(arguments=arguments)
                    outputID = object._id
                else:
                    break
            # print("RUN", obj, obj.run(arguments=arguments))

    def readInputMeta(self):
        IFaceNumber = self._objectRaw.attrs["module"]
        # IFaceNumber-Values:
        # IF1 = Master
        IFacePortNo = int(self._objectRaw.attrs["input"]) - 159
        # IFacePortNo-Values:
        # I1 = 160
        # I2 = 161
        # …
        # I8 = 167
        IFacePortMode = int(self._objectRaw.attrs["inputMode"])
        # IFacePortMode-Values:
        # 0  = D 10V   Sensor-Type  6   (Spursensor)
        # 1  = D 5k    Sensor-Types 1-3 (Taster, Fototransitor, Reed-Kontakt)
        # 3  = A 10V   Sensor-Type  8   (Farbsensor)
        # 4  = A 5k    Sensor-Types 4-5 (NTC-Widerstand, Fotowiderstand)
        # 10 = Ultra…  Sensor-Type  7   (Abstandssensor)
        return IFaceNumber, IFacePortNo, IFacePortMode
