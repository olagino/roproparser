#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
from bs4 import BeautifulSoup

__author__     = "Leon Schnieber"
__copyright__  = "Copyright 2018"
__credits__    = "fischertechnik GmbH"
__maintainer__ = "Leon Schnieber"
__email__      = "olaginos-buero@outlook.de"
__status__     = "Developement"


class RoboProObject(object):
    """
    This object can be either generated by an XML-String or via the attributes
    itself. Therefor objectXmlSoup has to be None so the attributes can be set
    manually. This feature is mainly used for Pseudo-Objects used on converging
    wires.
    """
    def __init__(self, subroutineToolbox, objectXmlSoup=None):
        self._objectRaw = objectXmlSoup
        self._subrtTools = subroutineToolbox
        self._data = None  # Empty variable e.g. to use for constants etc.
        self._type = None  # Category of the block, e.g. ftProProcessStart
        self._id = ""  # Internal ID given in the XML-Structure
        self._pins = []  # list of data- and flow-connection-pins
        if self._objectRaw is not None:
            self.parse()

    def __repr__(self):
        return "RoObj_" + self._id + "_" + self._type

    def parse(self):
        '''
        Extract all necessary informations about this Diagram-Block out of the
        given XML-Structure and store it in different Variables.
        '''
        self._type = self._objectRaw.attrs["classname"]
        try:
            self._id = self._objectRaw.attrs["id"]
        except KeyError:
            self._id = ""
        pinList = self._objectRaw.find_all("o", attrs=
            {"classname": "ftProObjectPin"})
        for pin in pinList:
            pinData = {
                "id": pin.attrs["id"],
                "pinid": pin.attrs["pinid"],
                "name": pin.attrs["name"],
                "pinclass": pin.attrs["pinclass"]
            }
            self._pins.append(pinData)

    def getPinIdByClass(self, pinclass):
        '''
        Fetch and return all connection pins of a given type
        '''
        return self.getPinIdByAttr("pinclass", pinclass)

    def getPinIdByAttr(self, attr, value):
        '''
        Fetch and return all connection pins of a given type and value
        '''
        list = []
        for pin in self._pins:
            if value in pin[attr]:
                list.append(pin["id"])
        return list

    def run(self, inputID=None):
        '''
        This function is called by the Subroutine-Object. Depending on its object
        type it takes additional input arguments (e.g. Input-Sensors or variables)
        and returns the next coutputID (e.g. important for an if-else-Block).
        Additionally it may return additional Arguments, e.g. for Motor-Outputs.
        '''
        outputID = None
        arguments = {}
        if self._type == "ftProProcessStart": # program start block
            outputID = self.getPinIdByClass("flowobjectoutput")[0]
        elif self._type == "ftProFlowIf":  # if block
            # Get Pin-IDs for the Yes-Outputs and No-Outputs
            outYes = self.getPinIdByAttr("name", "J")[0]
            outNo = self.getPinIdByAttr("name", "N")[0]
            # start backpropagating process to get a value for the comparsion
            pinIDin = self.getPinIdByClass("dataobjectinput")[0]
            # get the backpropagated value and return IDs depending on the value
            val = self.calculateDataValue(self._subrtTools, pinIDin)["value"]
            if val == 1 or val == True or val > 0:
                outputID = outYes
            else:
                outputID = outNo
        elif self._type == "ftProDataIn": # sensor/data-in block
            # fetch type dependent settings
            IFaceNumber = self._objectRaw.attrs["module"]
            # IFaceNumber-Values:
            # IF1 = Master
            IFacePortNo = int(self._objectRaw.attrs["input"]) - 159
            # IFacePortNo-Values:
            # I1 = 160
            # I2 = 161
            # …
            # I8 = 167
            IFacePortMode = self._objectRaw.attrs["inputMode"]
            # IFacePortMode-Values:
            # 0  = D 10V   Sensor-Type  6   (Spursensor)
            # 1  = D 5k    Sensor-Types 1-3 (Taster, Fototransitor, Reed-Kontakt)
            # 3  = A 10V   Sensor-Type  8   (Farbsensor)
            # 4  = A 5k    Sensor-Types 4-5 (NTC-Widerstand, Fotowiderstand)
            # 10 = Ultra…  Sensor-Type  7   (Abstandssensor)
            arguments["value"] = True
        elif self._type == "dataHelper": # merging Cable nodes
            pass
        elif self._type == "ftProDataMssg":
            pinIDIn = self.getPinIdByClass("dataobjectinput")
            if len(pinIDIn) >= 1:
                # backpropagate data from the connecting wires
                value = int(self.calculateDataValue(self._subrtTools, pinIDIn)["value"])
            else:
                # get the value from the metadata
                value = int(self._objectRaw.attrs["value"])
            outputCommandType = self._objectRaw.attrs["command"]
            # List of availiable types
            # "="    = Set      (= n)
            # "+"    = Incr     (= n+1)
            # "-"    = Decr     (= n-1)
            # "cw"   = CW Mot   (v=n)
            # "ccw"  = CCW Mot  (v=n)
            # "Stop" = Stop Mot (v=0)
            # "On"   = On IO    (v=n)
            # "Off"  = Off IO   (v=0)
            # "Ap…d" = Append n to list
            # "Re…e" = Remove nth list-element
            # "Swap" = Swap nth element with first element in list
            print(self._objectRaw)


            outputID = self.getPinIdByClass("dataobjectoutput")[0]
            # "frontpropagate" all output paths and call their "run"-Functions until having reached all of them
        else:
            print(self._type)
        return outputID, arguments

    def calculateDataValue(self, data, pinIDin):
        '''
        This function is especially important for objects who use data-flow-wires
        to get their information. It tries to backfollow the orange connections
        to their origins.
        '''
        dataInBack = data._followWireReverse(pinIDin)
        pins, objectBack = data._findObject(dataInBack)
        outputID, arguments = objectBack.run(data)
        return arguments
